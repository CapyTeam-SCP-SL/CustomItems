// -----------------------------------------------------------------------
// <copyright file="ImplosionGrenade.cs" company="CapyTeam SCP: SL">
// Copyright (c) CapyTeam SCP: SL. All rights reserved.
// Licensed under the CC BY-SA 3.0 license.
// </copyright>
// -----------------------------------------------------------------------

namespace CustomItemsReborn.Items;

using System;
using System.Collections.Generic;
using System.ComponentModel;
using CustomItemsReborn.API;
using CustomItemsReborn.API.Interfaces;
using Exiled.API.Enums;
using Exiled.API.Features;
using Exiled.Events.EventArgs.Map;
using Exiled.Events.EventArgs.Scp106;
using MEC;
using PlayerRoles;
using UnityEngine;
using Scp106 = Exiled.Events.Handlers.Scp106;

/// <summary>
/// Represents the Implosion Grenade (IG-119), a custom grenade that pulls nearby players toward its explosion center with minimal damage.
/// </summary>
public class ImplosionGrenade : CustomItemsAPI
{
    // Constants for explosion and suction parameters
    private const float ExplosionCenterOffsetY = 1.5f;
    private const float BaseFragDamage = 300f;
    private const float MinDamageModifier = 0f;
    private const int MinSuctionCount = 1;
    private const float MinSuctionPerTick = 0.01f;
    private const float MinSuctionTickRate = 0.01f;

    /// <summary>
    /// Stores serial numbers of all Implosion Grenade instances for efficient lookup.
    /// </summary>
    private readonly HashSet<ushort> _implosionGrenadeList = [];

    /// <summary>
    /// Tracks players affected by the grenade's suction effect.
    /// </summary>
    private readonly List<Player> _affectedPlayers = [];

    /// <summary>
    /// Stores active coroutines for suction effects.
    /// </summary>
    private readonly List<CoroutineHandle> _coroutines = [];

    /// <summary>
    /// Reference to the spawn API for creating pickups.
    /// </summary>
    private readonly SpawnAPI _spawnApi;

    /// <summary>
    /// Gets the display name of the item.
    /// </summary>
    public override string ItemName => "IG-119";

    /// <summary>
    /// Gets the base item type used for the Implosion Grenade.
    /// </summary>
    public override ItemType ItemType => ItemType.GrenadeHE;

    /// <summary>
    /// Gets the broadcast message shown when the item is picked up.
    /// </summary>
    public override string PickupBroadcast => "<b>You have picked up IG-119</b>";

    /// <summary>
    /// Gets the hint shown when the item is selected.
    /// </summary>
    public override string ChangeHint => "This grenade deals minimal damage but pulls nearby players toward its center.";

    /// <summary>
    /// Gets the List of serial numbers for tracking instances of this item.
    /// </summary>
    public override HashSet<ushort> ItemList => [.. _implosionGrenadeList];

    /// <summary>
    /// Gets or sets the percentage of normal frag grenade damage dealt.
    /// </summary>
    [Description("The % of normal frag-grenade damage this grenade will deal.")]
    public float DamageModifier
    {
        get => _damageModifier;
        set => _damageModifier = Math.Max(value, MinDamageModifier);
    }
    private float _damageModifier = 0.05f;

    /// <summary>
    /// Gets or sets the number of suction ticks generated by the grenade.
    /// </summary>
    [Description("The amount of suction ticks each grenade will generate.")]
    public int SuctionCount
    {
        get => _suctionCount;
        set => _suctionCount = Math.Max(value, MinSuctionCount);
    }
    private int _suctionCount = 90;

    /// <summary>
    /// Gets or sets the distance players are moved per suction tick.
    /// </summary>
    [Description("The distance each tick will move players towards the center.")]
    public float SuctionPerTick
    {
        get => _suctionPerTick;
        set => _suctionPerTick = Math.Max(value, MinSuctionPerTick);
    }
    private float _suctionPerTick = 0.125f;

    /// <summary>
    /// Gets or sets the interval between suction ticks in seconds.
    /// </summary>
    [Description("Tick interval in seconds.")]
    public float SuctionTickRate
    {
        get => _suctionTickRate;
        set => _suctionTickRate = Math.Max(value, MinSuctionTickRate);
    }
    private float _suctionTickRate = 0.025f;

    /// <summary>
    /// Gets or sets the roles immune to the grenade's suction effect.
    /// </summary>
    [Description("Roles which cannot be affected by IG-119.")]
    public List<RoleTypeId> BlackListedRoles { get; set; } = [RoleTypeId.Scp173, RoleTypeId.Tutorial];

    /// <summary>
    /// Initializes a new instance of the <see cref="ImplosionGrenade"/> class.
    /// </summary>
    public ImplosionGrenade()
    {
        _spawnApi = new SpawnAPI();
    }

    /// <summary>
    /// Spawns Implosion Grenade pickups in the game world.
    /// </summary>
    public override void CreateCustomItem()
    {
        try
        {
            if (_spawnApi == null)
            {
                Log.Error("SpawnAPI is null in ImplosionGrenade.CreateCustomItem.");
                return;
            }

            _spawnApi.CreateAndSpawnPickup(ItemType, RoomType.HczArmory, Vector3.zero, Quaternion.identity, _implosionGrenadeList);
            _spawnApi.CreateAndSpawnPickup(ItemType, RoomType.HczArmory, Vector3.zero, Quaternion.identity, _implosionGrenadeList);
            base.CreateCustomItem();
        }
        catch (Exception ex)
        {
            Log.Error($"Failed to create Implosion Grenade item: {ex.Message}\n{ex.StackTrace}");
        }
    }

    /// <summary>
    /// Subscribes to grenade explosion and SCP-106 teleporting events.
    /// </summary>
    protected override void SubscribeEvents()
    {
        Exiled.Events.Handlers.Map.ExplodingGrenade += OnExplodingGrenade;
        Scp106.Teleporting += OnTeleporting;
        base.SubscribeEvents();
        Log.Debug("Subscribed to events for Implosion Grenade.");
    }

    /// <summary>
    /// Unsubscribes from events and cleans up coroutines and affected players.
    /// </summary>
    protected override void UnsubscribeEvents()
    {
        Exiled.Events.Handlers.Map.ExplodingGrenade -= OnExplodingGrenade;
        Scp106.Teleporting -= OnTeleporting;

        try
        {
            foreach (CoroutineHandle handle in _coroutines)
                Timing.KillCoroutines(handle);
            _coroutines.Clear();
            _affectedPlayers.Clear();
        }
        catch (Exception ex)
        {
            Log.Error($"Error cleaning up coroutines in ImplosionGrenade.UnsubscribeEvents: {ex.Message}\n{ex.StackTrace}");
        }

        base.UnsubscribeEvents();
        Log.Debug("Unsubscribed from events for Implosion Grenade.");
    }

    /// <summary>
    /// Handles the grenade explosion to apply suction and minimal damage to nearby players.
    /// </summary>
    /// <param name="ev">The exploding grenade event arguments.</param>
    private void OnExplodingGrenade(ExplodingGrenadeEventArgs ev)
    {
        if (!IsValidExplosionEvent(ev))
            return;

        try
        {
            ev.IsAllowed = false;
            Vector3 center = ev.Projectile.Position + Vector3.up * ExplosionCenterOffsetY;

            ApplySuctionToPlayers(ev.TargetsToAffect, center);
            ApplyDamageToPlayers();

            ev.TargetsToAffect.Clear();
        }
        catch (Exception ex)
        {
            Log.Error($"Error in OnExplodingGrenade for Implosion Grenade: {ex.Message}\n{ex.StackTrace}");
        }
    }

    /// <summary>
    /// Validates the explosion event for Implosion Grenade functionality.
    /// </summary>
    /// <param name="ev">The exploding grenade event arguments.</param>
    /// <returns>True if the event is valid, otherwise false.</returns>
    private bool IsValidExplosionEvent(ExplodingGrenadeEventArgs ev)
    {
        return ev?.Projectile?.Info != null && IsSelectedCustomItem(ev.Projectile.Info.Serial, _implosionGrenadeList);
    }

    /// <summary>
    /// Applies suction to eligible players near the explosion center.
    /// </summary>
    /// <param name="targets">The players to consider for suction.</param>
    /// <param name="center">The center point of the suction.</param>
    private void ApplySuctionToPlayers(HashSet<Player> targets, Vector3 center)
    {
        foreach (Player player in targets)
        {
            if (!IsEligibleForSuction(player, center))
                continue;

            _affectedPlayers.Add(player);
            _coroutines.Add(Timing.RunCoroutine(DoSuction(player, center)));
            Log.Debug($"Started suction for player {player.Nickname} toward {center}.");
        }
    }

    /// <summary>
    /// Determines if a player is eligible for the suction effect.
    /// </summary>
    /// <param name="player">The player to check.</param>
    /// <param name="center">The center point of the suction.</param>
    /// <returns>True if the player can be affected, otherwise false.</returns>
    private bool IsEligibleForSuction(Player player, Vector3 center)
    {
        return player != null &&
               player.IsAlive &&
               !BlackListedRoles.Contains(player.Role) &&
               !Physics.Linecast(center, player.Position, Physics.DefaultRaycastLayers);
    }

    /// <summary>
    /// Applies damage to affected players based on the damage modifier.
    /// </summary>
    private void ApplyDamageToPlayers()
    {
        if (DamageModifier <= 0f)
            return;

        float damage = BaseFragDamage * DamageModifier;
        foreach (Player player in _affectedPlayers)
        {
            if (player.IsAlive)
            {
                player.Hurt(damage);
                Log.Debug($"Applied {damage} damage to player {player.Nickname}.");
            }
        }
    }

    /// <summary>
    /// Coroutine that applies the suction effect to a player over multiple ticks.
    /// </summary>
    /// <param name="player">The player to affect.</param>
    /// <param name="center">The center point of the suction.</param>
    /// <returns>An iterator for the coroutine.</returns>
    private IEnumerator<float> DoSuction(Player player, Vector3 center)
    {
        for (int i = 0; i < SuctionCount && player.IsAlive; i++)
        {
            Vector3 direction = (center - player.Position).normalized;
            Vector3 target = center + direction;
            player.Position = Vector3.MoveTowards(player.Position, target, SuctionPerTick);
            yield return Timing.WaitForSeconds(SuctionTickRate);
        }

        _affectedPlayers.Remove(player);
        Log.Debug($"Suction ended for player {player.Nickname}.");
    }

    /// <summary>
    /// Prevents SCP-106 from teleporting while affected by the suction effect.
    /// </summary>
    /// <param name="ev">The teleporting event arguments.</param>
    private void OnTeleporting(TeleportingEventArgs ev)
    {
        if (ev?.Player == null || !_affectedPlayers.Contains(ev.Player))
            return;

        try
        {
            ev.IsAllowed = false;
            Log.Debug($"Prevented SCP-106 teleport for player {ev.Player.Nickname} due to suction effect.");
        }
        catch (Exception ex)
        {
            Log.Error($"Error in OnTeleporting for Implosion Grenade: {ex.Message}\n{ex.StackTrace}");
        }
    }
}